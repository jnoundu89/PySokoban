
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="keywords" content="Sokoban solver &quot;scribbles&quot; by Florent Diedler about the Sokolution solver" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="Sokoban Wiki (en)" />
		<link rel="alternate" type="application/rss+xml" title="Sokoban Wiki RSS Feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Sokoban Wiki Atom Feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Sokoban solver &quot;scribbles&quot; by Florent Diedler about the Sokolution solver - Sokoban Wiki</title>
		<link rel="stylesheet" href="/wiki/skins/common/shared.css?207" type="text/css" media="screen" />
		<link rel="stylesheet" href="/wiki/skins/common/commonPrint.css?207" type="text/css" media="print" />
		<link rel="stylesheet" href="/wiki/skins/monobook/main.css?207" type="text/css" media="screen" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/wiki/skins/monobook/IE50Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/wiki/skins/monobook/IE55Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/wiki/skins/monobook/IE60Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/wiki/skins/monobook/IE70Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" media="print" />
		<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="/wiki/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/wiki/skins/common/IEFixes.js?207"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/wiki/skins";
		var wgArticlePath = "/wiki/index.php?title=$1";
		var wgScriptPath = "/wiki";
		var wgScript = "/wiki/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://sokobano.de";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Sokoban_solver_\"scribbles\"_by_Florent_Diedler_about_the_Sokolution_solver";
		var wgTitle = "Sokoban solver \"scribbles\" by Florent Diedler about the Sokolution solver";
		var wgAction = "view";
		var wgArticleId = "2189";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 6140;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/wiki/skins/common/wikibits.js?207"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/wiki/skins/common/ajax.js?207"></script>
		<script type="text/javascript" src="/wiki/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Sokoban_solver_scribbles_by_Florent_Diedler_about_the_Sokolution_solver skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">Sokoban solver &quot;scribbles&quot; by Florent Diedler about the Sokolution solver</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Sokoban Wiki</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p>"Scribbles" about Sokoban solver programming by Florent Diedler, in particular about the Sokolution solver.
</p>
<table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Sokolution_overall_structure"><span class="tocnumber">1</span> <span class="toctext">Sokolution overall structure</span></a></li>
<li class="toclevel-1"><a href="#Search_algorithms"><span class="tocnumber">2</span> <span class="toctext">Search algorithms</span></a></li>
<li class="toclevel-1"><a href="#Heuristic_score"><span class="tocnumber">3</span> <span class="toctext">Heuristic score</span></a></li>
<li class="toclevel-1"><a href="#Heuristic_update"><span class="tocnumber">4</span> <span class="toctext">Heuristic update</span></a></li>
<li class="toclevel-1"><a href="#Transposition_table_and_hash_function"><span class="tocnumber">5</span> <span class="toctext">Transposition table and hash function</span></a></li>
<li class="toclevel-1"><a href="#Open_queue"><span class="tocnumber">6</span> <span class="toctext">Open queue</span></a></li>
<li class="toclevel-1"><a href="#Goal_room_packing"><span class="tocnumber">7</span> <span class="toctext">Goal room packing</span></a></li>
<li class="toclevel-1"><a href="#Partial_goal_ordering"><span class="tocnumber">8</span> <span class="toctext">Partial goal ordering</span></a></li>
<li class="toclevel-1"><a href="#Pre-calculated_deadlock_positions"><span class="tocnumber">9</span> <span class="toctext">Pre-calculated deadlock positions</span></a></li>
<li class="toclevel-1"><a href="#Pre-calculated_penalty_positions"><span class="tocnumber">10</span> <span class="toctext">Pre-calculated penalty positions</span></a></li>
<li class="toclevel-1"><a href="#Pre-calculated_deadlock_in_the_goal_area"><span class="tocnumber">11</span> <span class="toctext">Pre-calculated deadlock in the goal area</span></a></li>
<li class="toclevel-1"><a href="#Macro_moves"><span class="tocnumber">12</span> <span class="toctext">Macro moves</span></a></li>
<li class="toclevel-1"><a href="#Dynamic_searching_of_deadlocks"><span class="tocnumber">13</span> <span class="toctext">Dynamic searching of deadlocks</span></a></li>
<li class="toclevel-1"><a href="#PI-Corral_pruning"><span class="tocnumber">14</span> <span class="toctext">PI-Corral pruning</span></a></li>
<li class="toclevel-1"><a href="#Brainstorming_and_ideas"><span class="tocnumber">15</span> <span class="toctext">Brainstorming and ideas</span></a></li>
<li class="toclevel-1"><a href="#Conclusion"><span class="tocnumber">16</span> <span class="toctext">Conclusion</span></a></li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a name="Sokolution_overall_structure" id="Sokolution_overall_structure"></a><h2> <span class="mw-headline"> Sokolution overall structure </span></h2>
<p>Sokolution is written in C++, uses STL library / C++14 concepts and is built with MinGW 5.1 under Windows 7 / 10. I chose C++ because it is a very fast low-level language really fast and we can have the full control of the memory thanks to the pointers.
</p><p>The only limit of my solver is the number of floor squares for a given level. Sokolution can solve *only* levels with less than 256 floor squares (walls do not count). This implies that the maximum number of boxes is 255. Then, Sokolution can solve levels up to 100 for width and 100 for height.
I choose this compromise because it is a limitation of bitsets, a binary structure in C++. It also allows all positions to be stored in only one byte which is great for the memory.
</p><p>Sokolution is compatible with host programs like Sokoban++ or YASC. The plugin version is just a DLL file that we need to place into the "Plugin" folder of the host program. There are no external dependencies.
</p><p>Sokolution is the best solver because everything is really optimized in memory and speed. I spent almost a year to profile and optimize all bottlenecks. All areas are "binarized" which means that each square is represented as a bit in memory. Because I use one byte to store the player position, the position can only vary from 0 to 255 included. This is the main drawback of my solver but it seems nonetheless worthwhile.
</p>
<a name="Search_algorithms" id="Search_algorithms"></a><h2> <span class="mw-headline"> Search algorithms </span></h2>
<p>Sokolution can use several algorithms according to your needs&nbsp;:
</p>
<ul><li> Optimal algorithms&nbsp;: BFS, IDDFS, A* and IDA
</li><li> Non-optimal algorithms&nbsp;: Greedy, DFS
</li></ul>
<p><br />
Each algorithm can use the FORWARD mode or the BACKWARD mode and some special modes can be used.
</p><p>The forward mode consists to start from the initial state and try to find a sequence of pushes to put all boxes on goals. This is the natural mode to solve Sokoban problems.
</p><p>The backward mode is the opposite of the forward mode. We start from the solution (all boxes are on goals) and we pull boxes in order to find the initial position. Note that the final player position should be able to reach its initial position.
</p><p>The bidirectional mode is a combination of forward and backward modes. A thread will perform the forward search and another thread will perform the backward search. There is no check when the two searches overlap.
</p><p>By default, Sokolution uses a bidirectional search with greedy algorithm in both side. This is the quickest way to find a solution.
</p><p>If you want to find optimal solutions, use a bidirectional search with A* algorithm in both side.
</p>
<a name="Heuristic_score" id="Heuristic_score"></a><h2> <span class="mw-headline"> Heuristic score </span></h2>
<p>All algorithms that require a heuristic use the bipartite matching. It is a long computation which uses the Hungarian algorithm in O(n^4) in time complexity. The Hungarian one has been modified a bit in order to be optimized in O(n^3).
</p><p>To solve sublevels, the heuristic uses the nearest goal for each box which is really fast.
</p>
<a name="Heuristic_update" id="Heuristic_update"></a><h2> <span class="mw-headline"> Heuristic update </span></h2>
<p>Assuming that the basic heuristic is sufficient to solve a Sokoban level is an error. Even if we use a really accurate method to find a perfect bipartite matching between boxes and goals, there are lots of situations where the basic heuristic is not sufficient. The basic heuristic is defined as the heuristic that does not take into account any other boxes.
</p><p>During the main search, we will find new frozen boxes on goals (otherwise it is a deadlock). Sometimes, these areas may change the heuristic score and affect the reachability of unfilled goals. To solve this problem, I recompute the heuristic after finding a frozen area. It is a long computation and we have to be smart to optimize this computation.
</p><p>With this enhancement, just computing the heuristic score can lead to detect new deadlocks due to a goal that is no more accessible. It helps a lot when we have no goal ordering available.
</p>
<a name="Transposition_table_and_hash_function" id="Transposition_table_and_hash_function"></a><h2> <span class="mw-headline"> Transposition table and hash function </span></h2>
<p>A custom transposition table is created especially for the solver. It is an open-addressing hashtable with linear probing. The memory is fully controlled in order to set a memory limit for this solver without the risk of having an overflow memory.
</p><p>After having implemented plenty of hash functions, I finally use the default hash function for bitset and I do a XOR with the player normalized position.
</p>
<a name="Open_queue" id="Open_queue"></a><h2> <span class="mw-headline"> Open queue </span></h2>
<p>Depending of the algorithm chosen, the open queue can be&nbsp;:
</p>
<ul><li> FIFO queue for BFS
</li><li> LIFO stack for DFS and IDDFS
</li><li> Priority queue for Greedy, A* and IDA
</li></ul>
<p>The tie-breaking for the priority queue is&nbsp;:
</p>
<ul><li> If a F-cost is defined, sort by minimum F-cost
</li><li> If a H-cost is defined, sort by minimum H-cost
</li><li> For same F or H costs, sort by newest node first
</li></ul>
<p>NB&nbsp;: F-cost is defined as the sum of G-cost and H-cost (F = G + H)
</p>
<a name="Goal_room_packing" id="Goal_room_packing"></a><h2> <span class="mw-headline"> Goal room packing </span></h2>
<p>Contrary to YASS solver, Sokolution does not use a "goal room packing" method. So it is impossible to solve XSokoban #50, XSokoban #66 and Xsokoban #69 levels that needed those powerful algorithms. I think YASS shines in this domain.
</p><p>However, Sokolution has an algorithm to find goal room when there is a single entrance (like many of XSokoban levels). If we are able to find an order of filling goal without creating deadlocks, Sokolution will create macro moves to respect the ordering of the goal area. This mechanism speeds up a lot levels with a "goal room theme".
</p>
<a name="Partial_goal_ordering" id="Partial_goal_ordering"></a><h2> <span class="mw-headline"> Partial goal ordering </span></h2>
<p>I think this is a real improvement in finding a non-optimal solution. It is quite impossible to guarantee optimality with a pre-calculated partial goal ordering. The aims is to find a subset of goals that should always be ordered before other goals. This subset of goals need also to be filled in a particular order.
</p><p>Let's take the XSokoban #35 level as example&nbsp;:
</p><p><a href="/wiki/index.php?title=File:Xsokoban_35.png" class="image" title="Xsokoban 35.png"><img alt="" src="/wiki/images/thumb/Xsokoban_35.png/200px-Xsokoban_35.png" width="200" height="169" border="0" /></a>
</p><p>First of all, there is no goal room in this level even if all goals are connected because there are two entrances. However, we know that we ought to fill the subset of goals (red rectangle) before any other goal. Otherwise we will create deadlocks due to inaccessible goals.
</p><p><a href="/wiki/index.php?title=File:Xsokoban_35_partial_ordering.png" class="image" title="Xsokoban 35 partial ordering.png"><img alt="" src="/wiki/images/thumb/Xsokoban_35_partial_ordering.png/200px-Xsokoban_35_partial_ordering.png" width="200" height="169" border="0" /></a>
</p><p>During the main search, we try to find macro moves in order to push a box into its final goal position <b>which respects the partial ordering</b>. When the subset of goals is filled, left goals are filled without any particular order.
</p><p>The main drawback of this algorithm is that it does not work with a goal area that the player can cross like in XSokoban #74 because we need to park boxes or cross the goal area before pushing boxes to their final position. It also does not work for scattered goals so it is not a good candidate for backward search.  For those kinds of levels, we have no choice but to disable the ordering engine.
</p>
<a name="Pre-calculated_deadlock_positions" id="Pre-calculated_deadlock_positions"></a><h2> <span class="mw-headline"> Pre-calculated deadlock positions </span></h2>
<p>There is a mechanism able to generate deadlock positions before starting the search. I called it a MPDB-X for Multiple Pattern DataBase for X boxes. The MPDB is a database that can store all deadlocks created by X boxes.
</p><p>However, it is too costly to generate all deadlocks for X &gt; 2. Moreover, nothing guarantees that these deadlocks are useful for the current level. So, it is better to find deadlocks dynamically during the search and store them in a database.
</p>
<a name="Pre-calculated_penalty_positions" id="Pre-calculated_penalty_positions"></a><h2> <span class="mw-headline"> Pre-calculated penalty positions </span></h2>
<p>There is also a mechanism able to generate positions that creates penalties in term of heuristic cost before starting the search. I call it a MPPDB-X for Multiple Pattern Penalty DataBase for X boxes. The MPPDB is a database that can store all penalties created by X boxes.
</p><p>Like the MPPDB-X, it is too costly to generate all penalties for X &gt; 2. Searching penalties is slower than searching deadlocks because we need to perform an optimal search for each pattern. For small patterns, we can use a simple BFS search that is quick enough.
</p><p>There is no dynamic detection of penalties during the main search.
</p><p>Note that a MPPDB-2 can get all linear conflicts created by 2 boxes.
</p>
<a name="Pre-calculated_deadlock_in_the_goal_area" id="Pre-calculated_deadlock_in_the_goal_area"></a><h2> <span class="mw-headline"> Pre-calculated deadlock in the goal area </span></h2>
<p>This feature is under development and I hope it will evolve some day.
</p><p>I really want to create a MPGADB for Multiple Pattern Goal Area DataBase but it is quite difficult. After seeing most of deadlock situations near or inside the goal area, I have noticed that some goals become inaccessible due to frozen boxes on goals. The heuristic can find a few of these situations like in this example&nbsp;:
</p><p><a href="/wiki/index.php?title=File:Xsokoban_16_frozen_heuristic.png" class="image" title="Xsokoban 16 frozen heuristic.png"><img alt="" src="/wiki/images/thumb/Xsokoban_16_frozen_heuristic.png/200px-Xsokoban_16_frozen_heuristic.png" width="200" height="213" border="0" /></a>
</p><p>But in this example&nbsp;:
</p><p><a href="/wiki/index.php?title=File:Xsokoban_45_deadlock.png" class="image" title="Xsokoban 45 deadlock.png"><img alt="" src="/wiki/images/thumb/Xsokoban_45_deadlock.png/200px-Xsokoban_45_deadlock.png" width="200" height="144" border="0" /></a>
</p><p>The heuristic does not see that the situation is already a deadlock even if you can assign all boxes on a goal with the Hungarian method. In fact, the two red goals cannot be filled at the same time. It is a kind of bipartite deadlock but applied to goals.
</p><p>The idea to solve these situations is to pre-compute what I call "a deadlock in the goal area with conditions".
</p><p>Let's take the previous example. Considering this position, the goals X and Y cannot be filled together because when the goal X will be filled , the goal Y will be inaccessible and in return if the goal Y is filled, the goal X will be inaccessible. As said before, it is a sort of "bipartite" deadlock.
</p><p>To detect these situations, we consider all frozen boxes on goal as walls. We start from a situation where the goal area is full and we try to escape boxes in backward mode (pulling). All boxes that cannot escape the goal area have a trouble and created the famous "condition".
</p><p>Now, we can store an entry in the MPGADB {goal area considered as wall, conditions}
</p><p>When we check the database, we need to check if the current goal area matches with an entry and if all goals in condition are filled. If one of them is not filled, we have a deadlock&nbsp;!
</p><p>The downside of this database is the cost of computation. As you can guess, it is really long to pre-compute the database.
</p><p>An idea can be to detect these situations during the search as for deadlocks. But I don't really know for now...
</p>
<a name="Macro_moves" id="Macro_moves"></a><h2> <span class="mw-headline"> Macro moves </span></h2>
<p>There are 3 kinds of macro moves implemented in Sokolution&nbsp;:
</p>
<ul><li> Macro Tunnel&nbsp;: Tunnels are precomputed before the search. We have tunnels called "one-way" and "two-way". One way tunnels are composed of articulation squares. An articulation square is a square that splits the maze into several parts if it is replaced by a wall. There are good candidate for PI-Corral pruning. Two way tunnels are tunnels where the player can go around it. These tunnels can be used to park temporary a box. When a box enters into a Tunnel, we can perform the macro move depending of the type and length of the tunnel. The macro tunnel does not affect the optimality of the solution.
</li></ul>
<ul><li> Macro Goal&nbsp;: Single goal room area are precomputed before the search. When a box enters into a goal room area by its single entrance, we can push this box to its final goal position. Note that we can miss the optimality of the solution with this macro move because sometimes we need to park a box inside the goal room area in order to have the best solution.
</li></ul>
<ul><li> Macro Goal Cut&nbsp;: When a partial ordering is available, we will generate macro moves in addition to other classical moves. The aim is to try to push a box directly to its final goal position according to the current ordering. Note that other boxes are considered as walls. These moves will have a better cost than regular moves, so they will be expanded first. For example, let's consider we have already ordered 2 goals. Before expanding children, we will check for macro moves in order to fill the third goal and so on.
</li></ul>
<a name="Dynamic_searching_of_deadlocks" id="Dynamic_searching_of_deadlocks"></a><h2> <span class="mw-headline"> Dynamic searching of deadlocks </span></h2>
<p>After studying all the literature about Sokoban, this wiki and seeing how the solver ran, I figure out that detecting all kind of deadlocks is barely impossible (without having a Super Calculator, maybe...).
</p><p>Sokolution can detect all *simple* deadlocks described <a href="http://sokobano.de/wiki/index.php?title=Deadlocks" class="external text" title="http://sokobano.de/wiki/index.php?title=Deadlocks" rel="nofollow">in this wiki</a>.
</p><p>During the search, Sokolution will look about corrals that are good candidates for deadlocks. When a deadlock is found, a process of minimization is launched in order to find the smallest pattern that creates the deadlock. It will allow being more efficient when finding deadlocks during the main search. These operations are really long and when patterns have too many boxes, it can take several hours to identify the deadlock (or just saying that this pattern is not a deadlock). To avoid this, we relax the rules to detect deadlocks when analyzing a pattern. If a box is not surrounded by other boxes, we can remove it from the pattern (it probably does not belongs to the deadlock). We can miss some deadlocks but it speed up considerably the search. As another improvement, we use a very fast heuristic here&nbsp;: the nearest goal for each boxes.
</p>
<a name="PI-Corral_pruning" id="PI-Corral_pruning"></a><h2> <span class="mw-headline"> PI-Corral pruning </span></h2>
<p>First of all, thanks to Brian Damgaard and Matthias Meger to have explained this marvellous concept in the wiki.
</p><p>I will not explain this concept and prefer <a href="http://sokobano.de/wiki/index.php?title=Solver#PI-Corrals" class="external text" title="http://sokobano.de/wiki/index.php?title=Solver#PI-Corrals" rel="nofollow">giving the link</a> for those of you who are interested.
</p><p>In the first versions (version 1.X), Sokolution has only a basic combined PI-Corral engine. In Sokolution 2.X the PI-Corral engine has been improved a bit and can detect more PI-Corral than the strict definition.
</p><p>Sokolution 3.X has a brand new PI-Corral engine. It was really hard to develop it but I am proud of expose its features&nbsp;:
</p>
<ul><li>The engine finds all simple corrals
</li><li>The engine finds combined corrals formed by two simple corrals
</li><li>The engine finds combined corrals formed by the player non-reachable area
</li></ul>
<p>Then, we analyze all corrals in order to find the best PI-Corral. The best PI-Corral is defined as&nbsp;:
</p>
<ul><li>First, PI-Corral with the more boxes on goal
</li><li>Then, PI-Corral with the less boxes on its frontier
</li><li>Then, PI-Corral with the smallest area
</li></ul>
<p>There is often PI-Corral in the goal area that creates a deadlock because one or more goals will be not accessible after resolving this PI-Corral. That is why, we prefer taking PI-Corral with the more boxes on goals against the fewer boxes on its frontier.
</p><p>Note: The PI-Corral pruning is only available in forward mode. There is no PO-Corral pruning in backward mode. I tried a lot of things but no result for now.
</p><p><br />
<b>Pi-Corral enhancement</b>
</p><p>Searching Pi-Corral allows finding some useful information about the disposition of boxes on the board. Sometimes, we discover a PI-Corral with all frontier boxes on goals and with no legal move available.
</p><p>Let's take the XSokoban #41 level&nbsp;:
</p><p><a href="/wiki/index.php?title=File:Xsokoban_41_frozen_picorral.png" class="image" title="Xsokoban 41 frozen picorral.png"><img alt="" src="/wiki/images/thumb/Xsokoban_41_frozen_picorral.png/200px-Xsokoban_41_frozen_picorral.png" width="200" height="158" border="0" /></a>
</p><p>In this level, red boxes form a valid PI-Corral. All boxes on its frontier are reachable for the player but we cannot open the corral because there are two dead-squares inside. What can we conclude&nbsp;? It is clear that frontier boxes are frozen (on goals otherwise it is a deadlock). Thus, I can improve the heuristic score with this new frozen area.
</p><p>To say that frontier boxes are frozen, we should be sure that the corral cannot be opened. We can guess two simple conditions&nbsp;:
</p>
<ul><li>all inside corral squares are dead
</li><li>there is less than 5 squares inside the corral
</li></ul>
<p>Perhaps, we can find other conditions but they are so many things to do with Sokoban that we cannot do all at the same time&nbsp;!
</p>
<a name="Brainstorming_and_ideas" id="Brainstorming_and_ideas"></a><h2> <span class="mw-headline"> Brainstorming and ideas </span></h2>
<p>To go further and try to solve more difficult levels, I thought about some ideas that can be good to investigate&nbsp;:
</p>
<ul><li> Performing a bidirectional search with frontier merging&nbsp;: The aim of this search is to perform a forward search in a thread and a backward search in another thread. The backward search try to find a node that belongs to the forward search. If we can find such a node, we have found a solution because forward and backward frontiers merged.
</li><li> Finding new deadlocks in the goal area. Instead of finding deadlocks outside the goal area, try to find deadlocks that create one or more inaccessible goals. It is the idea developed in the <i>Pre-calculated deadlock in the goal area</i> section of this article.
</li><li> Improve the backward search by finding something similar to PI-Corral. I tried a lot of things with no success.
</li><li> Improve the backward search by finding new kind of deadlocks.
</li><li> Implement a reordering of the goal area when possible. By example, the XSokoban #87 is a good candidate.
</li><li> Split a difficult level into small parts (divide and conquer&nbsp;!). By example, the Kenyam #20 is a good candidate because the center area is composed of deadsquares, so we can split the maze into 4 small parts that are really easy to solve.
</li><li> Improve the penalty engine by finding complex penalties that involve more than 2 boxes.
</li></ul>
<a name="Conclusion" id="Conclusion"></a><h2> <span class="mw-headline"> Conclusion </span></h2>
<p>I worked on Sokolution since January 2013, the project is almost finished because I don't want to have a burn-out. It was really hard to be focused on it during the last 5 years working sometimes until 3 a.m to debug a new feature or waiting for the end of a bench. It was a real pleasure to work on this subject and exchange information with Brian and Matthias.
</p><p>Even if I have a lack of self-confidence, I really don't realize that I have created the best solver of the world in the Sokoban world. I think I am proud of me even if very few people know this domain.
</p><p>That's all&nbsp;! I revealed all features inside Sokolution. I hope it will help other solvers to be more powerful and beat Sokolution&nbsp;:)
</p>
<!--
NewPP limit report
Preprocessor node count: 17/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key sokobano_wiki-wiki_:pcache:idhash:2189-0!1!0!!en!2!edit=0 and timestamp 20250607223936 -->
<div class="printfooter">
Retrieved from "<a href="http://sokobano.de/wiki/index.php?title=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver">http://sokobano.de/wiki/index.php?title=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver</a>"</div>
						<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>

				 <li id="ca-nstab-main" class="selected"><a href="/wiki/index.php?title=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="/wiki/index.php?title=Talk:Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource"><a href="/wiki/index.php?title=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="/wiki/index.php?title=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/wiki/images/basic/Wiki.png);" href="/wiki/index.php?title=Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/index.php?title=Main_Page">Main Page</a></li>
				<li id="n-currentevents"><a href="/wiki/index.php?title=Sokoban_Wiki:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-recentchanges"><a href="/wiki/index.php?title=Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-randompage"><a href="/wiki/index.php?title=Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
				<li id="n-help"><a href="/wiki/index.php?title=Help:Contents" title="The place to find out">Help</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Sokoban Wiki [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/index.php?title=Special:WhatLinksHere/Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/index.php?title=Special:RecentChangesLinked/Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-specialpages"><a href="/wiki/index.php?title=Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/wiki/index.php?title=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/wiki/index.php?title=Sokoban_solver_%22scribbles%22_by_Florent_Diedler_about_the_Sokolution_solver&amp;oldid=6140" title="Permanent link to this revision of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/wiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 27 March 2019, at 22:58.</li>
					<li id="viewcount">This page has been accessed 17,811 times.</li>
					<li id="privacy"><a href="/wiki/index.php?title=Sokoban_Wiki:Privacy_policy" title="Sokoban Wiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/index.php?title=Sokoban_Wiki:About" title="Sokoban Wiki:About">About Sokoban Wiki</a></li>
					<li id="disclaimer"><a href="/wiki/index.php?title=Sokoban_Wiki:General_disclaimer" title="Sokoban Wiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.011 secs. --></body></html>
